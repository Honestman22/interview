4.5.5 简单讲讲tomcat结构，以及其类加载器流程，线程模型等。
设来自客户的请求为：http://localhost:8080/test/index.jsp
请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得

Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应

Engine获得请求localhost:8080/test/index.jsp，匹配它所有虚拟主机Host

Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）

localhost Host获得请求/test/index.jsp，匹配它所拥有的所有Context

Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为""的Context去处理）

path="/test"的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet

Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类

构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法

Context把执行完了之后的HttpServletResponse对象返回给Host

Host把HttpServletResponse对象返回给Engine

Engine把HttpServletResponse对象返回给Connector

Connector把HttpServletResponse对象返回给客户browser


BIO,NIO,AIO,APR

4.5.6 tomcat如何调优，涉及哪些参数 

硬件上选择，操作系统选择，版本选择，jdk选择，配置jvm参数，配置connector的线程数量，开启gzip压缩，trimSpaces，集群等
4.5.7 讲讲Spring加载流程。
4.5.8 Spring AOP的实现原理。
4.5.9 讲讲Spring事务的传播属性。
4.6.0 Spring如何管理事务的。
4.6.1 Spring怎么配置事务（具体说出一些关键的xml 元素）。
4.6.2 说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原理，说说aop中的几个术语，它们是怎么相互工作的。
4.6.3 Springmvc 中DispatcherServlet初始化过程。
4.6.4 netty的线程模型，netty如何基于reactor模型上实现的。
4.6.5 为什么选择netty。
4.6.6 什么是TCP粘包，拆包。解决方式是什么。
4.6.7 netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。
4.6.8 netty的心跳处理在弱网下怎么办。
4.6.9 netty的通讯协议是什么样的。
4.7.0 springmvc用到的注解，作用是什么，原理。
4.7.1 springboot启动机制。
