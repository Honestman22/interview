https://blog.csdn.net/u014664750/article/details/78980133

## 8.有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。
 treeMap和LinkedHashMap是有序的（TreeMap默认升序，LinkedHashMap则记录了插入顺序）

## 9.抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。

1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。

2、抽象类要被子类继承，接口要被类实现。

3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现

4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。

5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方
法，那么该类也只能为抽象类。

6、抽象方法只能申明，不能实现。abstract void abc();不能写成abstract void abc(){}。

7、抽象类里可以没有抽象方法

8、如果一个类里有抽象方法，那么这个类只能是抽象类

9、抽象方法要被实现，所以不能是静态的，也不能是私有的。

10、接口可继承接口，并可多继承接口，但类只能单根继承。

## 10.  继承和聚合的区别在哪


## 11.IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。

传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。

需要说明的是等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在"干活"，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。

NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。

AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。

https://zhuanlan.zhihu.com/p/23488863

同步 vs. 异步

同步I/O　每个请求必须逐个地被处理，一个请求的处理会导致整个流程的暂时等待，这些事件无法并发地执行。用户线程发起I/O请求后需要等待或者轮询内核I/O操作完成后才能继续执行。

异步I/O　多个请求可以并发地执行，一个请求或者任务的执行不会导致整个流程的暂时等待。用户线程发起I/O请求后仍然继续执行，当内核I/O操作完成后会通知用户线程，或者调用用户线程注册的回调函数。

阻塞 vs. 非阻塞

阻塞　某个请求发出后，由于该请求操作需要的条件不满足，请求操作一直阻塞，不会返回，直到条件满足。

非阻塞　请求发出后，若该请求需要的条件不满足，则立即返回一个标志信息告知条件不满足，而不会一直等待。一般需要通过循环判断请求条件是否满足来获取请求结果。

需要注意的是，阻塞并不等价于同步，而非阻塞并非等价于异步。事实上这两组概念描述的是I/O模型中的两个不同维度。

同步和异步着重点在于多个任务执行过程中，后发起的任务是否必须等先发起的任务完成之后再进行。而不管先发起的任务请求是阻塞等待完成，还是立即返回通过循环等待请求成功。

而阻塞和非阻塞重点在于请求的方法是否立即返回（或者说是否在条件不满足时被阻塞）。

Unix下五种I/O模型

Unix 下共有五种 I/O 模型： 
- 阻塞 I/O  商场排队吃饭，只能老老实实排队，并且排队的时候不能做其他事情
- 非阻塞 I/O  还是商场吃饭，只是现在可以取号了。不过仍然需要时不时的去看一下有没有叫到号 cpu参与调度
- I/O 多路复用（select和poll）  还是商场吃饭，但是现在你可以在手机APP上同时叫多个号了，只要多个号里面有一个号好了就会通知你了
- 信号驱动 I/O（SIGIO） 商场吃饭，只要取了号，你也不用去一直看看大屏幕有没有好了，要是叫到号了，会主动发消息告诉你了
- 异步 I/O（Posix.1的aio_系列函数） 都不用去商场吃饭了，直接点个外卖，把等待上菜的时间也给省了


单线程模型，一个线程接收请求并且处理io

多线程模型，一个线程接收请求，多个线程处理io事件

从多线程模型 多个线程接收请求，多个线程处理io



## 12.反射的原理，反射创建类实例（class对象）的三种方式是什么。
https://blog.csdn.net/h2604396739/article/details/83109292
原理：获取内存里的class对象在里面查找，遍历

Classc1 = Class.forName("Employee");
//第二种方式：
//java中每个类型都有class 属性.
Classc2 = Employee.class;
 
//第三种方式：
//java语言中任何一个java对象都有getClass 方法
Employeee = new Employee();
Classc3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee)


## 13. 反射中，Class.forName和ClassLoader区别 。
在我们熟悉的Spring框架中的IOC的实现就是使用的ClassLoader。加载，链接，初始化


1、加载
Jvm把class文件字节码加载到内存中，并将这些静态数据装换成运行时数据区中方法区的类型数据，在运行时数据区堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。
*注：方法区不仅仅是存放方法，它存放的是类的类型信息。

2、链接：执行下面的校验、准备和解析步骤，其中解析步骤是可选的
a：校验：检查加载的class文件的正确性和安全性
b：准备：为类变量分配存储空间并设置类变量初始值，类变量随类型信息存放在方法区中,生命周期很长，使用不当和容易造成内存泄漏。
*注：类变量就是static变量；初始值指的是类变量类型的默认值而不是实际要赋的值
c：解析：jvm将常量池内的符号引用转换为直接引用

3、初始化：执行类变量赋值和静态代码块


Class.forName得到的class是已经初始化完成的
Classloder.loaderClass得到的class是还没有链接的 

spring ioc用的是classloder 同过懒加载控制

关于classLoader的详解
https://www.baidu.com/link?url=t-0eA8AGGRWQ_MQpHfqZx0EHu5kB_HsiDtFkGAkwQlTGgrT6f5scZm8ZvnzEAFFZn7QQdbf7RdYN4ZvGffpEs_&wd=&eqid=c7655b0400049f90000000065dd8a54b


## 14.描述动态代理的几种实现方式，分别说出相应的优缺点。

jdk动态代理实现

jdk动态代理是jdk原生就支持的一种代理方式，它的实现原理，就是通过让target类和代理类实现同一接口，代理类持有target对象，来达到方法拦截的作用，这样通过接口的方式有两个弊端，一个是必须保证target类有接口，第二个是如果想要对target类的方法进行代理拦截，那么就要保证这些方法都要在接口中声明，实现上略微有点限制。
　CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）
 cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理：

cglib有两种可选方式，继承和引用。第一种是基于继承实现的动态代理，所以可以直接通过super调用target方法，但是这种方式在spring中是不支持的，因为这样的话，这个target对象就不能被spring所管理，所以cglib还是才用类似jdk的方式，通过持有target对象来达到拦截方法的效果

jdk动态代理实现 创建代理类快，执行过程慢
cglib创建代理类慢，执行过程快

（基于invocationHandler和methodInterceptor）

## 15.z动态代理与cglib实现的区别。
动态代理基于反射，动态生成代理类
cglib基于asm字节码技术生成子类，覆盖父类的方法
## 16. 为什么CGlib方式可以对接口实现代理。
只要方法不被final修饰都可以

## 17.final的用途
 用final修饰的类不能被扩展，也就是说不可能有子类；
 
用final修饰的方法不能被替换或隐藏：

使用final修饰的实例方法在其所属类的子类中不能被替换（overridden）；

使用final修饰的静态方法在其所属类的子类中不能被重定义（redefined）而隐藏（hidden）；

用final修饰的变量最多只能赋值一次，在赋值方式上不同类型的变量或稍有不同：

静态变量必须明确赋值一次（不能只使用类型缺省值）；作为类成员的静态变量，赋值可以在其声明中通过初始化表达式完成，也可以在静态初始化块中进行；作为接口成员的静态变量，赋值只能在其声明中通过初始化表达式完成；

实例变量同样必须明确赋值一次（不能只使用类型缺省值）；赋值可以在其声明中通过初始化表达式完成，也可以在实例初始化块或构造器中进行；

方法参数变量在方法被调用时创建，同时被初始化为对应实参值，终止于方法体（body）结束，在此期间其值不能改变；

构造器参数变量在构造器被调用（通过实例创建表达式或显示的构造器调用）时创建，同时被初始化为对应实参值，终止于构造器体结束，在此期间其值不能改变；

异常处理器参数变量在有异常被try语句的catch子句捕捉到时创建，同时被初始化为实际的异常对象，终止于catch语句块结束，在此期间其值不能改变；

局部变量在其值被访问之前必须被明确赋值；

 
18. 写出三种单例模式实现 。
懒汉式，用到才去加载

/**
 * 单例模式：饿汉式
 * 在类加载时，就创建单例对象
 * 执行效率高，但是占空间，以空间换时间
 * 线程安全
 */
public class Hungry {

    private static final Hungry hungry = new Hungry();

    private Hungry(){}

    public static Hungry getInstance(){
        return  hungry;
    }
}
/**
 * 单例模式：懒汉式  双重判断
 * 对象使用的时候，才去创建
 * 有线程安全的风险，需要加锁
 */
public class Lazy1 {
    private   Lazy1(){}

    private static volatile Lazy1 instance = null;

    public static Lazy1 getInstance(){
        if(instance == null){
            synchronized (Lazy1.class){
                if(instance == null){
                    instance = new Lazy1();
                }
            }
        }
        return instance;
    }
}
多线程有问题，返回一个未初始化的对象
/**
 *单例模式：懒汉式  静态内部类
 * 静态内部类在使用时，才加载
 * 此种模式，既是懒加载，又没有加锁影响性能
 */
public class Lazy2 {
    private Lazy2(){}

    public static final Lazy2 getInstance(){
        return LazyLoad.instance;
    }

    private static class LazyLoad{
        private static final Lazy2 instance = new Lazy2();
    }
}


## 20.请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。

确保实现继承，多态，封装
public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。

private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。

protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。

default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问。

