数据库
======

## MySQL中的锁（表锁、行锁，共享锁，排它锁，间隙锁）

https://blog.csdn.net/soonfly/article/details/70238902

## 透彻解读mysql的可重复读、幻读及实现原理

https://blog.csdn.net/sanyuesan0000/article/details/90235335

## 数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。

1、脏读：B事务读取到了A事务尚未提交的数据
2、不可重复读：一个事务中两次读取的数据的内容不一致
3、幻读/虚读：一个事务中两次读取的数据的数量不一致

隔离级别
1、read uncommitted : 读未提交 ：哪个问题都不能解决   基于读取最新数据
2、read committed：读已提交 ：可以解决脏读 —- oracle默认的                       基于mvcc
3、repeatable read：可重复读：可以解决脏读和不可重复读 —mysql默认的              基于mvcc
4、serializable：串行化：可以解决脏读不可重复读和虚读—相当于锁表   基于数据行加读锁

## 什么是幻读。
3、幻读/虚读：一个事务中两次读取的数据的数量不一致

## MYSQL有哪些存储引擎，各自优缺点。
1.InnoDB 引擎(MySQL5.5以后默认使用)

灾难恢复性好
支持事务
使用行级锁
支持外键关联
支持热备份
对于InnoDB引擎中的表，其数据的物理组织形式是簇表（Cluster Table），主键索引和数据是在一起的，数据按主键的顺序物理分布
实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的获取
支持热备份

2.MyISAM引擎

特性如下：
不支持事务
使用表级锁，并发性差
主机宕机后，MyISAM表易损坏，灾难恢复性不佳
可以配合锁，实现操作系统下的复制备份、迁移
只缓存索引，数据的缓存是利用操作系统缓冲区来实现的。可能引发过多的系统调用且效率不佳
数据紧凑存储，因此可获得更小的索引和更快的全表扫描性能

区别
1）InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。
2）MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用
3）InnoDB支持外键，MyISAM不支持
4）从MySQL5.5.5以后，InnoDB是默认引擎
5）InnoDB不支持FULLTEXT类型的索引
6）InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表。
7）对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。
8）清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。
9）InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'


## 高并发下，如何做到安全的修改同一行数据。
悲观锁，乐观锁
## 乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。
乐观锁添加版本号，每次更新都比较这个版本号
悲观锁直接加select for update
共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。
共享锁也是读锁，加了读锁就不能再加写锁，但可以继续加读锁
排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。
排他锁写锁，加了写锁不能再加读锁，也不能加写锁
## SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。
查看慢日志（show [session|gobal] status ），定位慢查询，查看慢查询执行计划 根据执行计划确认优化方案
Explain sql
select_type:表示select类型。常见的取值有SIMPLE（简单表，即不使用连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（union中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个SELECT）等。
talbe：输出结果集的表。
type:表的连接类型。性能由高到底：system（表中仅有一行）、const（表中最多有一个匹配行）、eq_ref、ref、ref_null、index_merge、unique_subquery、index_subquery、range、idnex等
possible_keys:查询时，可能使用的索引
key:实际使用的索引
key_len:索引字段的长度
rows：扫描行的数量
Extra：执行情况的说明和描述
## 数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。

1）重启数据库（谁用谁知道）
2）杀掉抢资源的进程：
先查哪些进程在抢资源：SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
杀掉它们：Kill trx_mysql_thread_id；
## MYsql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。
索引原理；
索引是数据表种一个或者多个列进行排序的数据结构
索引能够大幅提升检索速度
创建、更新索引本身也会耗费空间和时间

线性查找：一个个找；实现简单；太慢
二分查找：有序；简单；要求是有序的，插入特别慢
HASH查找：查询快；占用空间；不太适合存储大规模数据
二叉查找树：插入和查询很快(log(n))；无法存大规模数据，复杂度退化
平衡树：解决 BST 退化问题，树是平衡的；节点非常多的时候，依然树高很高
多路查找树：一个父亲多个孩子节点（度）；节点过多树高不会特别深
多路平衡查找树：B-Tree


## 聚集索引和非聚集索引的区别。
## select for update 是什么含义，会锁表还是锁行或是其他。
## 为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。
## 数据库的ACID是什么。
## 某个表有近千万数据，CRUD比较慢，如何优化。
## Mysql怎么优化table scan的。
## 如何写sql能够有效的使用到复合索引。
## mysql中in 和exists 区别。
## 数据库自增主键可能的问题。
## MVCC的含义，如何实现的。
## 你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他
## 们的原理知道么。
## MYSQL的主从延迟怎么解决。
