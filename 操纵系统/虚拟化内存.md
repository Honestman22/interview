## 第13章 抽象地址空间
 
### 1， 虚拟化的3个目标
1，程序不应该感受到内存被虚拟化，程序感觉内存被他独占在使用（实际上多个程序在共享使用内存）
2，效率，虚拟化内存和物理内存的映射 需要tlb等硬件支持
3，保护，进程之间的内存时隔离的，


 ## 第15章 地址转换
 

通过基址寄存器和界限寄存器，基址寄存器，作为转换的基础，界限作为超出内存容量后 的异常处理

#### 问题：造成了内存的浪费(这种基址加界限，因为（代码块，栈，堆，）只有一个基址，一个界限， 物理内存也是连续的)
 
 ## 第16章 分段
 
  用虚拟地址开头的两位来表示段，（栈，堆，代码块），后面几位纪记录偏移量， 
   问题1，支持反向增长，硬件能判断
   问题2，内存是共享的，硬件提供保护位，保证这块内存(可读 或者可写)。
   
 #### 目的 解决了内存的浪费
 #### 新的问题：因为段大小不一，所以存在外部内存碎片（需要利用空闲列表；；； 如果一个堆本身就是很稀疏，分段也无法解决这种内存浪费（内部碎片-++++++++++）
 
 ## 第17章 空闲空间管理
 
 段内维护空闲列表， 是一个链表结构，
 空闲空间的管理策略，最有匹配，最差匹配等基本就是 在内存碎片和效率之间取舍
  #### 主流方式:1 分离空闲列表，将频繁申请的对象但用用一个空闲列表管理（例如锁，文件innode等） 2，伙伴系统 一直递归除以二
                
 
 ## 第18章 分页
 为了解决外部碎片的问题，将空间分割成固定长度，这就是分页
 
 虚拟地址的页号（vpn），映射物理地址的页号（PFN） 通过索引找ptf再找到vpn映射的pfn
 
 
 页表结构 ptf  有效位，如果无效，不会分配物理页
            保护位，同可读，可写
            存在位，保证是否存在磁盘
            脏位，判断这个页是否被修改过
           
            参开位，追踪页是否被访问
  #### 新的问题：页表占用内存较大，因为要维护所有的映射，会造成内存的浪费
