
4.7.2 Linux系统下你关注过哪些内核参数，说说你知道的。
、net.ipv4.tcp_syncookies
#此参数应该设置为1，防止SYN Flood。
处在SYN_RECV的TCP连接称为半连接，存储在SYN队列。大量SYN_RECV会导致队列溢出，后续请求将被内核直接丢弃，也就是SYN Flood攻击。开启syncookies后，当SYN队列满了后，TCP会通过原地址端口，目的地址端口和时间戳打造一个特别的Sequence Number(又叫cookie发回去，如果是攻击者则不会有响应，如果是正常连接则把这个SYNCookie发回来，然后服务器端可以通过cookie建立连接(即使不在SYN队列)。

2、net.ipv4.tcp_fin_timeout
#此参数默认值60，TCP保持在FIN_WAIT2状态的时间，超时后直接处于CLOSED，所以降低tcp_fin_timeout有助于减少TIME_WAIT数量。注意：虽然shutdown(SHUD_WR)也会处于FIN_WAIT2状态，但超时并不起作用。

3、net.ipv4.tcp_tw_recycle
#此参数默认值0，打开快速TIME_WAIT socket回收。
如果tcp_timestamps开启的话，会缓存每个连接的最新时间戳，如果后续请求时间戳小于缓存的时间戳，即视为无效，相应的包被丢弃。所以如果是在NAT(Network Address Translation)网络下，就可能出现数据包丢弃的现象，会导致大量的TCP连接建立错误。

4、net.ipv4.tcp_tw_resue
#此参数默认值0，是否重用TIME_WAIT状态的socket用于新的连接。
这个选项要比net.ipv4.tcp_tw_recycle安全，从协议的角度看，复用是安全的。复用条件:
1）net.ipv4.tcp_timestamps选项必须打开(客户端也必须打开) ；
2)  重用TIME_WAIT的条件是收到最后一个包后超过1秒；

5、net.ipv4.tcp_keepalive_time = 1200
#此参数表示TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，可改为20分钟。

4.7.3 Linux下IO模型有几种，各自的含义是什么。
![image](https://github.com/Honestman22/interview/blob/master/images/1577775661(1).jpg)
https://www.jianshu.com/p/486b0965c296

###4.7.4 epoll和poll有什么区别。

调用select时，会发生以下事情：

从用户空间拷贝fd_set到内核空间；
注册回调函数__pollwait；
遍历所有fd，对全部指定设备做一次poll（这里的poll是一个文件操作，它有两个参数，一个是文件fd本身，一个是当设备尚未就绪时调用的回调函数__pollwait，这个函数把设备自己特有的等待队列传给内核，让内核把当前的进程挂载到其中）；
当设备就绪时，设备就会唤醒在自己特有等待队列中的【所有】节点，于是当前进程就获取到了完成的信号。poll文件操作返回的是一组标准的掩码，其中的各个位指示当前的不同的就绪状态（全0为没有任何事件触发），根据mask可对fd_set赋值；
如果所有设备返回的掩码都没有显示任何的事件触发，就去掉回调函数的函数指针，进入有限时的睡眠状态，再恢复和不断做poll，再作有限时的睡眠，直到其中一个设备有事件触发为止。
只要有事件触发，系统调用返回，将fd_set从内核空间拷贝到用户空间，回到用户态，用户就可以对相关的fd作进一步的读或者写操作了。
epoll原理概述

调用epoll_create时，做了以下事情：

内核帮我们在epoll文件系统里建了个file结点；
在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket；
建立一个list链表，用于存储准备就绪的事件。
调用epoll_ctl时，做了以下事情：

把socket放到epoll文件系统里file对象对应的红黑树上；
给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。
调用epoll_wait时，做了以下事情：

观察list链表里有没有数据。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已。

总结如下：

一颗红黑树，一张准备就绪句柄链表，少量的内核cache，解决了大并发下的socket处理问题。

执行epoll_create时，创建了红黑树和就绪链表； 
执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据; 
执行epoll_wait时立刻返回准备就绪链表里的数据即可。

两种模式的区别：

LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时重复返回这个句柄，而ET模式仅在第一次返回。

两种模式的实现：

当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait检查这些socket，如果是LT模式，并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表。所以，LT模式的句柄，只要它上面还有事件，epoll_wait每次都会返回。

对比

select缺点:

最大并发数限制：使用32个整数的32位，即32*32=1024来标识fd，虽然可修改，但是有以下第二点的瓶颈；
效率低：每次都会线性扫描整个fd_set，集合越大速度越慢；
内核/用户空间内存拷贝问题。
epoll的提升：

本身没有最大并发连接的限制，仅受系统中进程能打开的最大文件数目限制；
效率提升：只有活跃的socket才会主动的去调用callback函数；
省去不必要的内存拷贝：epoll通过内核与用户空间mmap同一块内存实现。


4.7.5 平时用到哪些Linux命令。
Ls,find,tar,tail,cp,rm,vi，grep,ps,pkill

4.7.6 用一行命令查看文件的最后五行。
Tail -n 5 filename

4.7.7 用一行命令输出正在运行的java进程。
ps -ef|grep Java

4.7.8 介绍下你理解的操作系统中线程切换过程。


4.7.9 进程和线程的区别。


4.8.0 top 命令之后有哪些内容，有什么作用。


4.8.1 线上CPU爆高，请问你如何找到问题所在。


