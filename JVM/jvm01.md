4.4.2 什么情况下会发生栈内存溢出。
如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。


4.4.3 JVM的内存结构，Eden和Survivor比例。
Eden区是一块，Survivor区是两块。

Eden区和Survivor区的比例是8：1：1

JVM内存的结构为
堆：存放对象
栈：运行时存放栈帧
程序计数器
方法区：存放类和常量

Jdk 1.8之后好像取消了方法区，直接将永久代放到了本地内存里面。

4.4.4 JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。

当Eden区装满后，Minor GC进行垃圾回收，幸存的对象会直接放入老年代，可以想到，要不了多久老年代就会装满，便会进行Major GC且连带Minor GC也就是Full GC，每次Full GC都会消耗大量的时间。

当Eden区填满后，Minor GC进行垃圾回收，幸存的对象会移动到Survivor区，这样循环往复。此时，Survivor区被装满了，也会进行Minor GC，将一些对象kill掉，幸存的对象只能保存在原来的位置，这样就会出现大量的内存碎片（被占用内存不连续）。

4.4.5 JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。
  对象诞生即新生代->eden，在进行minor gc过程中，如果依旧存活，移动到from，变成Survivor，进行标记代数，如此检查一定次数后，晋升为老年代，

4.4.6 你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。
Serial、parNew、ParallelScavenge、SerialOld、ParallelOld、CMS、G1

4.4.7 垃圾回收算法的实现原理。
4.4.8 当出现了内存溢出，你怎么排错。
4.4.9 JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
4.5.0 简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
4.5.1 讲讲JAVA的反射机制。
4.5.2 你们线上应用的JVM参数有哪些。
4.5.3 g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。
4.5.4 怎么打出线程栈信息。
