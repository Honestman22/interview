 
 TCP与HTTP
=========
## 1、TCP、UDP的区别？

TCP与UDP区别总结：

1)、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。

2)、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3)、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，可以控制分多次读，读得多或者读得少;UDP是面向报文的，报文必须一次读完
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4)、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5)、TCP首部开销20字节;UDP的首部开销小，只有8个字节

6)、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

首先ip层不保证数据正确性，数据正确性由tcp，Udp层保证，通过校验和
（7）tcp比udp，多序列号吗（seq），确认号码（ack），flag，窗口大小，紧急指针，
tcp额外的保证 
TCP通过ack解决消息丢失
通过seq解决重复和乱序的问题



## Tcp 粘包拆包的原因

应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包

接收方法不及时读取套接字缓冲区数据，这将发生粘包

## 9、select、poll、epoll的机制及其区别？

1).单个进程打开的文件描述符（fd文件句柄）不一致

select ：有最大连接数限制数为1024，单个进程所能打开的最大连接数由FD_ZETSIZE宏定义。

poll：poll本质上与select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的。

epoll：虽然连接有上限，但是很大，1G内存的机器可以打开10万左右的连接，以此类推。

2).监听Socket的方式不一致

select ：轮询的方式，一个一个的socket检查过去，发现有socket活跃时才进行处理，当线性socket增多时，轮询的速度将会变得很慢，造成线性造成性能下降问题。

poll：对select稍微进行了优化，只是修改了文件描述符，但是监听socket的方式还是轮询。

expoll：epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，通知expoll来处理这个socket。（会将连接的socket注册到epoll中, 相当于socket的花名册, 如果有一个socket活跃了, 会回调一个函数, 通知epoll,赶紧过来处理）

3).内存空间拷贝方式（消息传递方式）不一致

select：内核想将消息传递到用户态，需要将数据从内核态拷贝到用户态,这个过程非常的耗时

poll：同上

epoll：epoll的内核和用户空间共享一块内存，因此内存态数据和用户态数据是共享的

select、poll、epoll时间复杂度分别是：O(n)、O(n)、O(1)

## http1.0和http1.1有什么区别。
HTTP的特点是无状态的，多个请求之间是没有关系的
客户端通过cookie保持状态
服务端通过session保持状态

HTTP1.0	 无状态、无连接
HTTP1.1	持久连接，请求管道化，增加缓存处理（新的字段如cache-control），增加Host字段、支持断点传输等（把文件分成几部分）
HTTP2.0	二进制分帧，多路复用（或连接共享），头部压缩，服务器推送

## TCP拥塞控制，流量控制。
 TCP流量控制 使用滑动窗口，流量窗口，滑动窗口使用完就得等待 
 
 假如，服务端B向客户端A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwind=400的报文段，然而这个报文段在传送中丢失 了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。这样就死锁了。为了解决这种死锁状态，TCP为每个连接设有一个持续计时器。只 要TCP连接的一方收到对方的零窗口通知，就启动持续计时器，若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带1字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。
 
 TCP拥塞控制
 发送方维持一个叫做 拥塞窗口cwnd（congestion window）的状态变量。拥塞窗口的大小变化取决于网络的拥塞程度，也取决于流量窗口限制
 
 
 慢启动 窗口指数性增大  ，当窗口达到 慢开始门限ssthresh，
 
 
 拥塞避免 窗口线性增大
 

 快速重传，收到3个重复的ack你立马重试，不需要等到超时时间重试

  快速恢复，cwnd设置为ssthresh，拥塞避免 ssthresh调整cwnd的一半
  快速重传和快速恢复是紧跟着的
  
## TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。
3次握手
1，客户端发送syn 进入SYN-SENT状态
2，服务端接收syn，发送ack SYN-RCVD
3，客户端发送 ack 服务端接收 建立连接进入ESTABLISHED

4次挥手
1，客户端发送fin 进入 fin-wait1
2，服务端接收报文 发送ack 进入 close-wait
客户端接收报文 进入FIN-WAIT-2
3，服务端等待数据发送完后，发送ack给客户端
4，客户端发送ack给服务端 进入TIME-WAIT
服务端接收消息就关闭，客户端等待2Msl后关闭
为什么客户端最后还要等待2MSL？

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

## TIME_WAIT和CLOSE_WAIT的区别。
TIME_WAIT 客户端等待链接关闭
CLOSE_WAIT 服务端等待传完数据

## 说说你知道的几种HTTP响应码，比如200, 302, 404。
1xx：信息，请求收到，继续处理
2xx：成功，行为被成功地接受、理解和采纳
3xx：重定向，为了完成请求，必须进一步执行的动作
4xx：客户端错误，请求包含语法错误或者请求无法实现
5xx：服务器错误，服务器不能实现一种明显无效的请求
https://my.oschina.net/gavinjin/blog/42856

## 当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。
 Dns解析–>端口分析–>tcp请求–>服务器处理请求–>服务器响应–>浏览器解析—>链接关闭
 or
 域名解析--> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求--> 浏览器得到html代码 --> 浏览器解析html代码，并请求html代码  中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户
## TCP/IP如何保证可靠性，说说TCP头的结构。
　  1: 校验和  发送方发送数据会通过一个算法和接收方进行比对
   
　　2: 序列号  TCP传输时将每个字节的数据都进行了编号，这就是序列号，服务端就收数据会回复接收的序列号
  
　　3: 确认应答 ，服务端就收数据会回复接收的序列号
  
　　4: 超时重传 没收到应答就会重传
  
　　5: 连接管理 tcp3次握手4次挥手
  
　　6: 流量控制 滑动窗口，服务端缓冲区装满了会丢包，用滑动窗口限流
  
　　7: 拥塞控制 满启动，速度慢慢变大：
  
  TCP头 源端口号，目标端口号，32位序号，32位确认号，4位头部长度，窗口大小，校验和，紧急指针，选项，头结构最多40个字节，一次数据最多1480字节TT
  
## TCP头结构和UDP头结构
TCP报头：
（1）16位端口号：告诉主机该报文段是来自哪里，以及传给哪个上层协议或者应用程序（目的端口）的。

（2）32位序号：给发送的数据编号。（随机值+偏移量（偏移量决定序号的大小））；32位序号能够指定数据传送过去的序号。

作用：A、保证发送的数据有序；B、保证重复的数据报被丢弃。

（3）32位确认号：对A端发送的数据进行确认并回馈的序号。（在32位序中的序号值加1返回回去）。

作用：保证数据能够有效地到达对端。
（4）4位头部长度：因为4位最大能表示15，所以最大为60个字节。

（5）6位标志位：
PSH：通知尽快读取数据；
RST：请求重新建立连接；
SYN：请求建立连接；
FIN：请求断开连接；
ACK：表示确认号是否有效；
URG：表示禁忌之阵是否有效。
（6）16位窗口大小：控制发送数据的速度或流量。
（7）16位校验和：由发送端填充，接收端对TCP报文段在传输过程中是否损坏。检验不仅包括头部部分，还包括数据部分。
（8）16位紧急指针：一个正的偏移量（相当于当前序号的偏移）。紧急指针是发送端向接收端发送紧急数据的方法。
TCP的特点的可靠性就体现在：32位序号，32位确认号16位校验和。面向连接体现在：URG、RST、SYN、FIN、ACK、PSH等六位标志。
、、

UDP报文头
（1）用户数据报长度：包括报头和数据部分的总长度。
（2）校验和：UDP协议不做错误纠正，发现错误会丢弃掉并发出警告。

## TCP/IP数据传输的过程
客户端将要准备发送的数据发给服务端，服务端接收数据，网卡将数据传到内核，内核把数据转到用户空间通过select函数监听，

## 如何避免浏览器缓存。
1，HTTP 信息头中包含 Cache-Control:no-cache，pragma:no-cache，或 Cache-Control:max-age=0 等告诉浏览器不用缓存的请求
2，需要根据 Cookie，认证信息等决定输入内容的动态请求是不能被缓存的
3，经过 HTTPS 安全加密的请求（有人也经过测试发现，ie 其实在头部加入 Cache-Control：max-age 信息，firefox 在头部加入 Cache-Control:Public 之后，能够对 HTTPS 的资源进行缓存，参考《HTTPS 的七个误解》）
5，POST 请求无法被缓存
6，HTTP 响应头中不包含 Last-Modified/Etag，也不包含 Cache-Control/Expires 的请求无法被缓存

## 如何理解HTTP协议的无状态性。
对事物协议对事物没有记忆能力
每个请求独立

## 简述Http请求get和post的区别以及数据包格式。

![image](https://github.com/Honestman22/interview/blob/master/images/1578540006(1).jpg)

请求行
请求头
请求体（get没有请求体）

## HTTP有哪些method
GET 方法的首要目的是 获取资源
POST 一般用于添加资源
HEAD 用于头部检验
PUT 与 PATCH 更新
DELETE用于删除
## 简述HTTP请求的报文格式。
请求行
请求头
请求体

## HTTP的长连接是什么意思。
保持连接不断开就是长连接

#### HTTPS的加密方式是什么，讲讲整个加密解密流程。
对称加密，非对称加密
SSL/TLS层是位于应用层和传输层之间，应用层的数据不再直接传递给传输层，而是传递给SSL/TLS层，对传过来的数据进行加密，并增加相应的头信息。

1，客户端发起https请求到服务端（服务器端要一套数字证书，可以自己制作，也可以向组织申请），向服务器端索要公钥就是证书。
2.服务端接收到客户端的请求后回应客户端以及公钥（证书就是一对公钥私钥）传给客户端。如果带有Session ID，直接恢复对话。
3，客户端收到服务端发来的公钥后会解析证书，首先是由TLS层来验证服务端证书是否有效，比如说颁发机构、有效时间、证书中的域名与当前会话域名是否匹配等。
证书校验没有问题的话，生成一个premaster secret（另一个随机值），然后用服务端发过来的证书对该随机值进行加密。
4，服务器用证书的私钥解密后，得到了客户端传过来的随机值（给信息加密的私钥），然后

服务器握手结束通知，该报文也作为校验消息，供客户端验证

5，服务端利用这个随机值私钥加密数据并发送数据给客户端，加密的数据可以被还原
6，客户端接收到这份数据后，利用随机值私钥解密这段数据，



## Http和https的三次握手有什么区别。
服务端用RSA生成公钥和私钥，把公钥放在证书里发送给客户端，私钥自己保存

客户端接收到公钥后，首先向一个权威的服务器检查证书的合法性，如果证书合法，客户端产生一段随机数，这个随机数就作为通信的密钥，我们称之为对称密钥，用公钥加密这段随机数，然后发送到服务器

服务器用密钥解密获取对称密钥，然后，双方就已对称密钥进行加密解密通信了

## 什么是分块传送。
将响应主体分成若干块，并在每一块前面加上该块数据的长度以及回车换行，这样Recipient（如浏览器）就可以根据这个长度值正确接收每一块数据，最后以一个0长度的分块作为消息体的结束标志。采用该传输方式Sender在开始传输响应内容到Recipient前不需要知道内容的长度。

## Session和cookie的区别。
(1)cookie数据存放在客户的浏览器上，session数据放在服务器上
(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session
(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE
(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。
(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中


