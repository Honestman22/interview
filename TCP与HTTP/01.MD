 
 TCP与HTTP
=========

#### http1.0和http1.1有什么区别。
HTTP的特点是无状态的，多个请求之间是没有关系的
客户端通过cookie保持状态
服务端通过session保持状态

HTTP1.0	 无状态、无连接
HTTP1.1	持久连接，请求管道化，增加缓存处理（新的字段如cache-control），增加Host字段、支持断点传输等（把文件分成几部分）
HTTP2.0	二进制分帧，多路复用（或连接共享），头部压缩，服务器推送

## TCP拥塞控制，流量控制。

#### TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。
3次握手
1，客户端发送syn 进入SYN-SENT状态
2，服务端接收syn，发送ack SYN-RCVD
3，客户端发送 ack 服务端接收 建立连接进入ESTABLISHED
4次挥手
1，客户端发送fin 进入 fin-wait1
2，服务端接收报文 发送ack 进入 close-wait
客户端接收报文 进入FIN-WAIT-2
3，服务端等待数据发送完后，发送ack给客户端
4，客户端发送ack给服务端 进入TIME-WAIT
服务端接收消息就关闭，客户端等待2Msl后关闭
为什么客户端最后还要等待2MSL？

MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。
第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。
第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

#### TIME_WAIT和CLOSE_WAIT的区别。
TIME_WAIT 客户端等待链接关闭
CLOSE_WAIT 服务端等待传完数据
#### 说说你知道的几种HTTP响应码，比如200, 302, 404。
1xx：信息，请求收到，继续处理
2xx：成功，行为被成功地接受、理解和采纳
3xx：重定向，为了完成请求，必须进一步执行的动作
4xx：客户端错误，请求包含语法错误或者请求无法实现
5xx：服务器错误，服务器不能实现一种明显无效的请求
https://my.oschina.net/gavinjin/blog/42856

#### 当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。
 Dns解析–>端口分析–>tcp请求–>服务器处理请求–>服务器响应–>浏览器解析—>链接关闭
 or
 域名解析--> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求--> 浏览器得到html代码 --> 浏览器解析html代码，并请求html代码  中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户
## TCP/IP如何保证可靠性，说说TCP头的结构。
　  1: 校验和  发送方发送数据会通过一个算法和接收方进行比对
   
　　2: 序列号  TCP传输时将每个字节的数据都进行了编号，这就是序列号，服务端就收数据会回复接收的序列号
  
　　3: 确认应答 ，服务端就收数据会回复接收的序列号
  
　　4: 超时重传 没收到应答就会重传
  
　　5: 连接管理 tcp3次握手4次挥手
  
　　6: 流量控制 滑动窗口，服务端缓冲区装满了会丢包，用滑动窗口限流
  
　　7: 拥塞控制 满启动，速度慢慢变大：
  
  TCP头 源端口号，目标端口号，32位序号，32位确认号，4位头部长度，窗口大小，校验和，紧急指针，选项，头结构最多40个字节，一次数据最多1480字节
#### TCP/IP数据传输的过程
客户端将要准备发送的数据发给服务端，服务端接收数据，网卡将数据传到内核，内核把数据转到用户空间通过select函数监听，
#### 如何避免浏览器缓存。
1，HTTP 信息头中包含 Cache-Control:no-cache，pragma:no-cache，或 Cache-Control:max-age=0 等告诉浏览器不用缓存的请求
2，需要根据 Cookie，认证信息等决定输入内容的动态请求是不能被缓存的
3，经过 HTTPS 安全加密的请求（有人也经过测试发现，ie 其实在头部加入 Cache-Control：max-age 信息，firefox 在头部加入 Cache-Control:Public 之后，能够对 HTTPS 的资源进行缓存，参考《HTTPS 的七个误解》）
5，POST 请求无法被缓存
6，HTTP 响应头中不包含 Last-Modified/Etag，也不包含 Cache-Control/Expires 的请求无法被缓存
#### 如何理解HTTP协议的无状态性。
对事物协议对事物没有记忆能力
每个请求独立
#### 简述Http请求get和post的区别以及数据包格式。

![image](https://github.com/Honestman22/interview/blob/master/images/1578540006(1).jpg)

请求行
请求头
请求体（get没有请求体）
#### HTTP有哪些method
GET 方法的首要目的是 获取资源
POST 一般用于添加资源
HEAD 用于头部检验
PUT 与 PATCH 更新
DELETE用于删除
#### 简述HTTP请求的报文格式。
请求行
请求头
请求体
#### HTTP的长连接是什么意思。
保持连接不断开就是长连接
#### HTTPS的加密方式是什么，讲讲整个加密解密流程。
对称加密，非对称加密
SSL/TLS层是位于应用层和传输层之间，应用层的数据不再直接传递给传输层，而是传递给SSL/TLS层，对传过来的数据进行加密，并增加相应的头信息。

1，客户端发起https请求到服务端（服务器端要一套数字证书，可以自己制作，也可以向组织申请），向服务器端索要公钥就是证书。
2.服务端接收到客户端的请求后回应客户端以及公钥（证书就是一对公钥私钥）传给客户端。如果带有Session ID，直接恢复对话。
3，客户端收到服务端发来的公钥后会解析证书，首先是由TLS层来验证服务端证书是否有效，比如说颁发机构、有效时间、证书中的域名与当前会话域名是否匹配等。
证书校验没有问题的话，生成一个premaster secret（另一个随机值），然后用服务端发过来的证书对该随机值进行加密。
4，服务器用证书的私钥解密后，得到了客户端传过来的随机值（给信息加密的私钥），然后

服务器握手结束通知，该报文也作为校验消息，供客户端验证

5，服务端利用这个随机值私钥加密数据并发送数据给客户端，加密的数据可以被还原
6，客户端接收到这份数据后，利用随机值私钥解密这段数据，



## Http和https的三次握手有什么区别。
服务端用RSA生成公钥和私钥，把公钥放在证书里发送给客户端，私钥自己保存

客户端接收到公钥后，首先向一个权威的服务器检查证书的合法性，如果证书合法，客户端产生一段随机数，这个随机数就作为通信的密钥，我们称之为对称密钥，用公钥加密这段随机数，然后发送到服务器

服务器用密钥解密获取对称密钥，然后，双方就已对称密钥进行加密解密通信了
## 什么是分块传送。
将响应主体分成若干块，并在每一块前面加上该块数据的长度以及回车换行，这样Recipient（如浏览器）就可以根据这个长度值正确接收每一块数据，最后以一个0长度的分块作为消息体的结束标志。采用该传输方式Sender在开始传输响应内容到Recipient前不需要知道内容的长度。
## Session和cookie的区别。
(1)cookie数据存放在客户的浏览器上，session数据放在服务器上
(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session
(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE
(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。
(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中


